<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[冒泡排序总结]]></title>
    <url>%2F2019%2F06%2F26%2FBubbleSort%2F</url>
    <content type="text"><![CDATA[冒泡排序总结冒泡排序​ 冒泡排序的主要思想是：数组a[0…n-1]依次比较相邻项，数值大者将不断后移（就像烧开的水不停向上冒泡一样），第i轮比较将使得a[n-i…n-1]有序，最多在n-1轮时整个数组将有序。 ​ 下面我们以a[7]={6，5，8，7，10，9}为例，下面是整个过程的示意图： 冒泡排序Java实现1234567891011121314public class BubbleSort&#123; public static bubbleSort(int[] a)&#123; int tmp = 0; for(int i = a.length-1;i &gt; 0;i--)&#123; for(int j = 0;j &lt; i;j++)&#123; if(a[j] &gt; a[j+1])&#123; tmp = a[j+1]; a[j+1] = a[j]; a[j] = tmp; &#125; &#125; &#125; &#125;&#125; 冒泡排序改进​ 从上面的例子中我们发现在第一轮比较完就已经有序了，但是按上面冒泡排序的实现还是会进行四轮比较，这大大浪费了时间。 ​ 改进方向：我们发现当序列有序后做一轮相邻比较下来是不会发生swap操作的，所以在这里我们可以用一个flag来表示一轮比较下来是否发生了swap操作。如果没有没有发生swap操作，就说明序列已经有序了，直接break就行啦。 ​ 改进的冒泡排序算法Java实现如下： 12345678910111213141516171819public class BubbleSort &#123; public static void BubbleSort(int[] a)&#123; int tmp = 0; boolean flag; for(int i = a.length-1;i &gt; 0;i--)&#123; flag = false; for(int j = 0;j &lt; i;j++)&#123; if(a[j] &gt; a[j+1])&#123; flag = true; tmp = a[j+1]; a[j+1] = a[j]; a[j] = tmp; &#125; &#125; if(!flag) break; &#125; &#125;&#125; 冒泡排序时间复杂度​ 我们分析最坏复杂度，T(n)=(n-1)+(n-2)+(n-3)+…+1=n(n-1)/2，所以冒泡排序的时间复杂度为O(n*n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroServices]]></title>
    <url>%2F2019%2F05%2F30%2FMicroServices%2F</url>
    <content type="text"><![CDATA[MicroServices​ 本文是我将Martin Fowler博客中的一篇名为MicroServices的文章翻译而成。文中的图片也都引用自该博客。 微服务这个新架构术语的一个定义​ 术语“微服务”在过去的几年里如雨后春笋般涌现。“微服务”描述了一种特别的软件应用设计方法。这种软件应用设计方法将软件应用设计为可独立部署的服务套件。虽然对于这一架构风格还没有精确的定义，但是围绕着组织方式、业务能力、自动部署、终端智能以及对于语言和数据的去中心化控制有着某些共同特征。 ​ 微服务-让人眼花缭乱的软件架构中的又一新名字。微服务描述了一种我们发现越来越有吸引力的软件系统风格。在最近的几年中，我们发现很多项目在用这个风格并且结果也很棒。微服务正在成为创建企业级应用的默认风格。然而遗憾的是还没有足够的信息说明微服务风格是什么以及怎样去做。 ​ 简而言之，微服务架构就是将单个应用开发成运行在自己的流程之上的一个个小型服务的套件，这些小型服务之间通过轻量级的机制（通常是HTTP resource API）进行通信。这些服务围绕着业务功能来创建，通过全自动部署机制独立部署。这些服务是可集中管理的最小限度，这些服务呢可以使用不同的编程语言和不同的数据存储技术来实现。 ​ 将微服务风格与单片风格（一个单片应用就只由一个单元组成）作比较将有助于解释微服务架构。企业级应用一般由三个主要部分组成：1、客户端用户接口（包括HTML页面和运行在用户机器上浏览器中的JavaScript脚本）2、数据库（包括插入进一种熟知的通常是关系型的数据库管理系统的很多张表）3、服务端应用程序。服务端应用程序能够处理HTTP请求，执行域逻辑，检索和更新数据库中的数据，然后选择并生成HTML视图发送给浏览器。这个服务端应用程序是一个单一的可执行逻辑。对于系统的任何一点变化都要生成和部署这个服务端应用程序的新版本。 ​ 使用单片风格去构建这样一个系统是很自然的想法。处理一个请求的所有逻辑放在一个单独的流程里。你可以使用你所用的语言的特性来将应用分解成类、方法以及名字空间等。你可以在一台开发者电脑上运行和测试应用系统，还可以使用一个部署管道来确保更改已经经过测试并且部署到生产环境中。你可以水平的扩展这个单片系统通过在负载均衡器后面运行多个实例。 ​ 单片应用可以说是成功的，但是越来越多的人对单片应用感觉到失望特别是随着越来越多的应用被部署到云平台上。单片应用在需要改变时所有东西都紧密的联系着。应用中的一小部分的改变却需要整个系统进行重新编译和部署。随着时间的推移很难保持一个比较好的模块结构，很难使改变仅仅发生在那个需要改变的模块中。扩展应用时往往需要对整个应用进行扩展而不是对仅仅需要更多资源的那一个部分进行扩展。 ​ 单片应用的这些问题使得微服务架构风格出现：将应用构建成服务套件。服务是独立部署和扩展的并且每一个服务也提供了严格的模块边界，甚至允许不同的服务可以用不同的编程语言去编写。相应的，这些服务也可以由不同的团队去管理。 ​ 我们并不是说微服务风格有多么新颖或创新，其实它的起源至少可以追溯到Unix操作系统的设计理论上。但是我们认为还是没有足够的人考虑到微服务架构，如果使用微服务架构，许多软件开发会更好。 微服务架构的特征​ 在这里呢我们并没有微服务架构风格的一个正式定义，但是我们可以试图去描述符合微服务架构理念的一些共同特征。并不是所有微服务架构都有全部这些特征，但是我们真的希望大多数微服务架构具有这里的大多数特征。尽管我们的作者一直是这个相当松散的社区中积极成员，但我们的目的是试图描述我们工作中所看到的和我们知道的其他团队相似的工作。特别的是我们没有规定一些要符合的定义。 通过服务组件化​ 只要在软件工程行业中我们就有一个愿望，就是能够通过将组件集合在一起从而构建系统，就像我们在现实世界中看到的那样。在过去的几十年里，我们看到大多数语言平台上大量的公共库都有了可观的发展。 ​ 当谈到组件时，我们遇到了组件构成这个困难的定义问题。我们的定义是一个组件是软件系统中一个可独立替换与升级的单元。 ​ 微服务架构也会用库，但是它将软件组件化的主要方式是将软件分解为服务。我们认为库是链接到一个程序（我们称之为内存函数调用）中的组件，而服务是进程外的组件，它们之间通过例如web服务请求或者远程过程调用这样的机制来进行通信。（这和面向对象程序中的service对象是不同的概念） ​ 使用服务作为组件的一个主要原因是服务是可以独立部署的。如果你的应用中在一个进程中包含了很多库，那么对于任一组件的变化都要对整个应用进行重新部署。但是如果将应用分解为多个服务，你就可以期盼单个服务的变化仅仅需要将这单个服务重新部署即可。这并不是绝对的，一些会改变服务接口的变化会需要进行协调。一个好的微服务架构的目标就是在服务调用间凝聚服务边界和演化机制来最小化这种需要改变服务接口的情况。 To be continued… Martin Fowler原文链接： https://martinfowler.com/articles/microservices.html]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
